<!DOCTYPE html>
<html>
<head>
  <title>math.js | basic usage</title>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/mathjs/3.20.1/math.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-beta/katex.min.css" integrity="sha384-L/SNYu0HM7XECWBeshTGLluQO9uVI1tvkCtunuoUbCHHoTH76cDyXty69Bb9I0qZ" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-beta/katex.min.js" integrity="sha384-ad+n9lzhJjYgO67lARKETJH6WuQVDDlRfj81AJJSswMyMkXTD49wBj5EP004WOY6" crossorigin="anonymous"></script>


<style>
        body,
        html,
        table td,
        table th,
        input[type=text] {
          font-size: 11pt;
          font-family: verdana, arial, sans-serif;
        }
    
        h1 {
          font-size: 11pt;
        }
    
        input[type=text] {
          padding: 5px;
          width: 400px;
        }
    
        table {
          border-collapse: collapse;
        }
    
        table td,
        table th {
          padding: 5px;
          border: 1px solid lightgray;
        }
    
        table th {
          background-color: lightgray;
        }
    
      </style>

</head>


<body>


<p> testpara</p>

    <p class="output"> para 2</p>

    <h1>
            Expression evaluation with math.js, pretty printing with Katex
          </h1>
          
          
          
          <table>
            <tr>
              <th>Expression</th>
              <td><input type="text" id="expr"/></td>
            </tr>
            <tr>
              <th>Pretty print</th>
              <td><div id="pretty">$$$$</div></td>
            </tr>
            <tr>
              <th>Result</th>
              <td><div id="result"></div></td>
            </tr>
              <tr>
              <th>transfo</th>
              <td><div id="transfo"></div></td>
            </tr>
          </table>
          <b>Parenthesis option:</b>
          <input type="radio" name="parenthesis" value="keep" onclick="parenthesis = 'keep'; expr.oninput();" checked>keep
          <input type="radio" name="parenthesis" value="auto" onclick="parenthesis = 'auto'; expr.oninput();">auto
          <input type="radio" name="parenthesis" value="all" onclick="parenthesis = 'all'; expr.oninput();">all
          <br/>
          <b>Implicit multiplication:</b>
          <input type="radio" name="implicit" value="hide" onclick="implicit = 'hide'; expr.oninput();" checked>hide
          <input type="radio" name="implicit" value="show" onclick="implicit = 'show'; expr.oninput();">show
          

    <p > inclusie in deze para 
<script>

var out = document.querySelector(".output");

  var expr = document.getElementById('expr'),
      pretty = document.getElementById('pretty'),
      result = document.getElementById('result'),
      transfo = document.getElementById('transfo'),
      parenthesis = 'keep',
      implicit = 'hide';

// Selectfunctie en andere speciale functies

var customFunctions = {
    // deze werkt nu nog niet met een willekeurig aantal elementen!!!
  Plus: function () {
//     arguments is een object met alle argumenten die zijn meegegeven met deze functie erin

// de argumenten van de plus functie zijn een object, maar moeten eerst naar een array worden omgezet
var argumentArray = Object.values(arguments);
// Tel steeds de eerste op met de som van de rest van de array (reduce) en bekom zo de totale som
sum = argumentArray.reduce(function (a,b) {return a + b;});
return sum;
  },
  Times: function () {
//     arguments is een object met alle argumenten die zijn meegegeven met deze functie erin

// de argumenten van de Times functie zijn een object, maar moeten eerst naar een array worden omgezet
var argumentArray = Object.values(arguments);
// Tel steeds de eerste op met de som van de rest van de array (reduce) en bekom zo de totale som
product = argumentArray.reduce(function (a,b) {return a * b;});
return product;
  },
  minus: function (a, b) {
    return a - b;
  },
  binom: function (n, k) {
    return 1;
  },
  Select: function (a) {
    return a;
  }


};

customFunctions.Plus.toTex = function (node, options) {
    
    console.log('plusinputnode: ');
    console.log(node);
    totalargs = node.args.length;
    outputs = [];

    for (i=0; i<totalargs; i++) {
        outputs.push(node.args[i].toTex(options));
        console.log(outputs);
    };
    console.log('plusoutputs');
    console.log(outputs.join(' + '));
    return outputs.join(' + ');
};

customFunctions.Times.toTex = function (node, options) {
    
    console.log('timesinputnode: ');
    console.log(node);

    totalargs = node.args.length;
    outputs = [];
    for (i=0; i<totalargs; i++) {
        outputs.push(node.args[i].toTex(options));
    };
    console.log(outputs.join(' * '));
    return outputs.join(' * ');
};
customFunctions.binom.toTex = '\\mathrm{${name}}\\left(${args}\\right)'; //template string
customFunctions.minus.toTex = function (node, options) { return node.args[0].toTex(options) 
  + node.name + node.args[1].toTex(options);
};
customFunctions.Select.toTex = function (node, options) {
    console.log('slct');
  return '\\textcolor{red}{' + node.args[0].toTex(options) + '}';
};

math.import(customFunctions);

// einde speciale functies (oa select)

// invert functie van internet (support voor dubbele values). Accepteert alleen arrays als keys in het originele object

var invert = function(input) {
      var output = {}

      Object.keys(input).forEach(function(key) {
        var value = input[key]
        output[value] = output[value] || []
        output[value].push(key.split(','))
      })

      return output
}

// niet destructief alternatief voor pop()
function returnWithoutLast(arr) {
newarr = [];
    for (i=0; i < arr.length - 1; i++) {
        newarr[i] = arr[i];
    };
return newarr;
};

// bouw een object met als keys de adressen in de uitdrukking bignode en als values het symbool op elk adres

function buildPath(bignode) {

  var adress = [];
  var lastChildAtLevel = [];
  var adressList = new Object;

    bignode.traverse(function (child,arg,parent) {

switch (child.type) {
    case 'OperatorNode': name = child.op;    break;
    case 'ConstantNode': name = child.value; break;
    case 'FunctionNode': name = child.fn;    break;
    case 'SymbolNode':   name = child.name;  break;
    default:             name = child.type;
  }

 if (arg==null) {arg='root?'}

 switch (arg.slice(0,4)) {
     case 'args':    argnum = /\d+/.exec(arg); break ;
     case 'cont':   argnum = 0; break; 
     default:       argnum = 8;
 }

 if (parent == null) {
     totalargs = 0
 } else {
    parent.args == undefined ? totalargs = 0 : totalargs = parent.args.length - 1
 }

 var leaf = child.args == undefined & child.content == undefined;
 var lastChild = argnum == totalargs;

 adress.push(arg);

// console.log(name + ':' + adress);

 adressList[adress] = name;

// console.log('arg:'+ arg + 'argnum: '+argnum + 'totalargs:' + totalargs);

if (lastChild) {
        lastChildAtLevel[adress.length]=1;
    };
 //   console.log(lastChildAtLevel);
 //   console.log('lastChild=' + lastChild);

 if (leaf == 1) {
     
    adress.pop()

 //   console.log('leafpop');

    if (lastChild == true) {

 //       console.log('leaf+lastChild');

        while (lastChildAtLevel[lastChildAtLevel.length -1 ] == 1) {
            adress.pop();
            lastChildAtLevel.pop();
 //           console.log('poptit: '+ lastChildAtLevel.length);
        };
     //   adress.pop();
    };
    

};

    }
    );

 return adressList;
};

// geeft een array terug met alle adressen van de gevraagde string in de uitdrukking bignode
function adresses(string, bignode) {
    return invert(buildPath(bignode))[string];
}

// geeft de uitdrukking die op het gegeven adres staat in de uitdrukking bignode
function readAtAdress(adress,bignode) {

    var node = math.parse('');

    for (i = 0; i < adress.length; i++) {
        arg = adress[i];
        switch (arg.slice(0,4)) {
            case 'root':   node = bignode; console.log('readroot'); break;
            case 'args':    node = node.args[/\d+/.exec(arg)]; console.log('readargs['+/\d+/.exec(arg)+']'); break;
            case 'cont':   node = node.content; console.log('readcontent'); break; 
            default:        alert('error: non-valid adress: ' + arg);
        };
        
    };

    return node;
;}

function injectAtAdress(subst,adress,bignode) {
    if (typeof subst === 'string') { subst = math.parse(subst)};

    var eq = bignode;
    var adressText = '';

    for (i = 0; i < adress.length; i++) {
        arg = adress[i];
        switch (arg.slice(0,4)) {
            case 'root':    adressText = ''; /* console.log(arg, adressText) */; break;
            case 'args':    adressText = adressText + '.args[' + /\d+/.exec(arg) + ']'; /* console.log(arg, adressText) */; break;
            case 'cont':   adressText = adressText + '.content'; /* console.log(arg, adressText) */; break; 
            default:        alert('error: non-valid adress' + arg);
        };
        
    };

 //   console.log('adrestext:' + adressText + ' subst: ' + subst);
// PAS OP WANT DIT IS DESTRUCTIEF en vERANDERT DE OORSPRONKELIJKE VARIABELE !!!
// IS DAT ECHT ZO? CHECK DIT!
    eval('eq'+adressText+ '= subst');
    return eq;
};

// zet een Select() rond de gegeven uitdrukking (mag in stringvorm of in objectvorm zijn)
function selectIt(node) {
    if (typeof node === 'string') { node = math.parse(node)};
    return new math.expression.node.FunctionNode('Select', [node]);
}

// vervangt wat nu geselecteerd is in bignode door de opgegeven substitutie (mag in stringvorm of in objectvorm zijn)
// de substitutie moet zelf al een Select bevatten want deze functie voegt die niet toe
function substituteSelected(subst, bignode) {
    if (typeof subst === 'string') { subst = math.parse(subst)};

    // replace in all select adresses
    adresses('Select', bignode).forEach(function (adress) {
        injectAtAdress(subst,adress,bignode);
}
    );
    return bignode;
};

/* OUDE VERSIE MET TRANSFORM FUNCTIE
function substituteSelected(subst, bignode) {
    
 subst = subst.replace('Select', 'Salect');
 subst = math.parse(subst);

    eq = bignode.transform(function (node, path, parent) {
  if (node.name === 'Select') {
      console.log('subbed')
    return subst;
  }

//  }
  else {
      console.log('nosub')
      return node;
  }
});

eq = eq.transform(function (node, path, parent) {
  if (node.name === 'Salect') {
      console.log('subbed')
    return math.parse('Select(' + node.args[0] + ')');
  }

  else {
      console.log('nosub')
      return node;
  }
});

return eq

};
 */


var equation = math.parse('');
var keysList = [];

selected = function (node) {
      
var filtered = node.filter(function (node) {
  return node.isFunctionNode && node.name === 'Select';
});

return filtered;

}

updateEval = function (node) {
    
    antwoord = equation.compile().eval();
    antwoord ? result.innerHTML = antwoord.toString() : result.value = '' ;
    
};

updateLatex = function (node) {
    try {
        // update expression

        expr.value = equation;

      // export the expression to LaTeX
        var latex = node ? node.toTex({parenthesis: parenthesis, implicit: implicit}) : '';
//      console.log('LaTeX expression:', latex);
        var largeLatex = '\\large ' + latex;
        var hugeLatex = '\\Huge ' + latex;

      // display and re-render the expression
      katex.render(largeLatex, pretty);
    }
    catch (err) {pretty.innerHTML = "error!!!"}
    updateEval(node);
}

updateLatex(equation);

// verplaatst de selectie naar het gevraagde adress
// past global variabele equation aan!
function MoveSelectToAdress(selectAdress,newAdress,eq) {
    // select eruit halen (dit werkt is getest)
    var cleanedEquation = eq.transform(function (child, path, parent) {
        if (child.fn == 'Select') {return child.args[0] } else { return child};
    });
console.log('cleaned');

 eq = injectAtAdress(selectIt(readAtAdress(newAdress, cleanedEquation)),newAdress,cleanedEquation);
 console.log('injected');
 equation = eq;

};

function replaceWithPlus() {
//    expr.value = 'Plus(3, Times(3, Select(4), 5), 7)';

substitution = 'Select(x) + y';
equation = substituteSelected( substitution, equation);
updateLatex(equation);
}

function replaceWithTimes() {

substitution = 'Select(a) * b';
equation = substituteSelected( substitution, equation);
updateLatex(equation);
}
function replaceWithPower() {

substitution = 'Select(a) ^ b';
equation = substituteSelected( substitution, equation);
updateLatex(equation);

}
function replaceWithMinus() {

substitution = '(Select(a)-b)';
equation = substituteSelected( substitution, equation);
updateLatex(equation);
}
function replaceWithDivide() {

substitution = 'Select(a) / b';
equation = substituteSelected( substitution, equation);
updateLatex(equation);
}
function replaceWithNthroot() {

substitution = 'nthRoot(Select(a),b)';
equation = substituteSelected( substitution, equation);
updateLatex(equation);
}
function replaceWithEquality() {
    equation = math.parse('Select(a)==b');
    updateLatex(equation);
}

function leftSelect(eq) {

// bereken het nieuwe adres voor select
// dit is maar 1 enkel selectadres dus momenteel werkt deze functie alleen voor enkele selecties 
selectAdress = adresses('Select',eq)[0];
console.log('selectAdress: ');
console.log(selectAdress);

// als Select maar 1 kind heeft: doe niks: ONDERSTAANDE CODE WERKT NIET WANT MOET OVER PARENT GAAN IPV OVER selectNode
// eigenlijk moet dit niet niet gecontroleerd worden voor links
// selectNode = readAtAdress(selectAdress,eq);
// if (selectNode.args[1] == undefined) {console.log('only one argument'); return};
// console.log('more than one argument');

    // als Select al de root is: doe niks
    if (eq.fn == 'Select') {return}; 

// vind het nummer van dit argument
if (selectAdress[selectAdress.length - 1] == 'content') {
    huidigNummer = 0;
} 
else {
    huidigNummer = Number(/\d+/.exec(selectAdress[selectAdress.length -1])[0]);
};

upAdress = returnWithoutLast(selectAdress);
console.log('upAdress: ');
console.log(upAdress);

nieuwNummer = Math.max(0,huidigNummer - 1);

if (selectAdress[selectAdress.length - 1] == 'content') {
    leftAdress = upAdress.concat(['content']);
} 
else {
    leftAdress = upAdress.concat(['args[' + nieuwNummer +']']);
};

console.log('leftAdress: ');
console.log(leftAdress);

MoveSelectToAdress(selectAdress,leftAdress,eq);

updateLatex(equation);

}

function rightSelect(eq) {
    // bereken het nieuwe adres voor select
// dit is maar 1 enkel selectadres dus momenteel werkt deze functie alleen voor enkele selecties 
selectAdress = adresses('Select',eq)[0];
console.log('selectAdress: ');
console.log(selectAdress);

// als Select maar 1 kind heeft: doe niks: ONDERSTAANDE CODE WERKT NIET WANT MOET OVER PARENT GAAN IPV OVER selectNode
// eigenlijk moet dit niet niet gecontroleerd worden voor links
// selectNode = readAtAdress(selectAdress,eq);
// if (selectNode.args[1] == undefined) {console.log('only one argument'); return};
// console.log('more than one argument');

    // als Select al de root is: doe niks
    if (eq.fn == 'Select') {return}; 

// vind het nummer van dit argument, en het aantal argumenten
if (selectAdress[selectAdress.length - 1] == 'content') {
    huidigNummer = 0;
} 
else {
    huidigNummer = Number(/\d+/.exec(selectAdress[selectAdress.length -1])[0]);
};
console.log('huidigNummer: ');
console.log(huidigNummer);

upAdress = returnWithoutLast(selectAdress);
console.log('upAdress: ');
console.log(upAdress);

upNode = readAtAdress(upAdress, eq);
upNode.args == undefined ? laatsteNummer = 0 : laatsteNummer = upNode.args.length - 1;
console.log('laatsteNummer: ' + laatsteNummer);

nieuwNummer = Math.min(huidigNummer + 1,laatsteNummer);
console.log('nieuwNummer: ' + nieuwNummer);

if (selectAdress[selectAdress.length - 1] == 'content') {
    rightAdress = upAdress.concat(['content']);
} 
else {
    rightAdress = upAdress.concat(['args[' + nieuwNummer +']']);
};
console.log('rightAdress: ');
console.log(rightAdress);

MoveSelectToAdress(selectAdress,rightAdress,eq);

updateLatex(equation);
}

function upSelect(eq) {
    // als Select al de root is: doe niks
if (eq.fn == 'Select') {return}; 
    // bereken het nieuwe adres voor select

// dit is maar 1 enkel selectadres dus momenteel werkt deze functie alleen voor enkele selecties    
selectAdress = adresses('Select',eq)[0];
console.log('selectAdress: ');
console.log(selectAdress);

upAdress = returnWithoutLast(selectAdress);
console.log(' upAdress: ');
console.log(upAdress);

//     // select eruit halen (dit werkt is getest)
//     var cleanedEquation = eq.transform(function (child, path, parent) {
//         if (child.fn == 'Select') {return child.args[0] } else { return child};
//     });
// console.log('cleaned');

//  eq = injectAtAdress(selectIt(readAtAdress(upAdress, cleanedEquation)),upAdress,cleanedEquation);
//  console.log('injected');
//  equation = eq;

MoveSelectToAdress(selectAdress,upAdress,eq);

updateLatex(equation);
}

function downSelect(eq) {

// dit is maar 1 enkel selectadres dus momenteel werkt deze functie alleen voor enkele selecties    
selectAdress = adresses('Select',eq)[0];
console.log('selectAdress: ');
console.log(selectAdress);

selectNode = readAtAdress(selectAdress,eq);

// als Select een leaf is: doe niks
    if (selectNode.args[0].args == undefined & selectNode.args[0].content == undefined) {return};
// ALLEEN ALS GEEN CONTENT ALS CONTENT DAN select.adress.content
if (selectNode.args[0].content == undefined) {downAdress = selectAdress.concat(['args[0]']);} 
else if (selectNode.args[0].args == undefined) {downAdress = selectAdress.concat(['content']);}
else {return};

console.log(' downAdress: ');
console.log(downAdress);

//     // select eruit halen (dit werkt is getest)
//     var cleanedEquation = eq.transform(function (child, path, parent) {
//         if (child.fn == 'Select') {return child.args[0] } else { return child};
//     });
// console.log('cleaned');

//  eq = injectAtAdress(selectIt(readAtAdress(downAdress, cleanedEquation)),downAdress,cleanedEquation);
//  console.log('injected');
//  equation = eq;

MoveSelectToAdress(selectAdress,downAdress,eq);

 updateLatex(equation);
}


// wat er gebeurt als je iets rechtstreek invult in de expressiebox
expr.oninput = function () {
    
    equation = math.parse(expr.value)
    updateLatex(equation);
    
}

 document.onkeydown = keysPressed
  
function  keysPressed(e) {

if (e.shiftKey == 1)
    switch (e.keyCode) {
// pijltjes met shift
        case 37: out.innerHTML = 'left'; break;
        case 38: out.innerHTML = 'up'; break;
        case 39: out.innerHTML = 'right'; break;
        case 40: out.innerHTML = 'down'; break;

// Speciale cijfers met shift
        case 53: equation = math.parse(expr.value); updateLatex(equation); break;
        case 54: updateLatex(equation); break;

// letters met shift
        case 65: ; break; // shift a
        case 66: ; break; // shift b
        case 67: ; break; // shift c

    }



else if (e.ctrlKey == 1)
    switch (e.keyCode) {
        case 37: out.innerHTML = 'CTRLleft';break;
        case 38: out.innerHTML = 'up'; break;
        case 39: out.innerHTML = 'right'; break;
        case 40: out.innerHTML = 'down'; break;
    }

else if (e.metaKey == 1)

    switch (e.keyCode) {
        case 37: out.innerHTML = 'left'; break;
        case 38: out.innerHTML = 'up'; break;
        case 39: out.innerHTML = 'right'; break;
        case 40: out.innerHTML = 'down'; break;

        case 70: e.preventDefault(); out.innerHTML = 'meta f'; break;
    }

else if (e.altKey == 1)

    switch (e.keyCode) {
        case 37: out.innerHTML = 'left'; break;
        case 38: out.innerHTML = 'up'; break;
        case 39: out.innerHTML = 'right'; break;
        case 40: out.innerHTML = 'down'; break;
    }

else

    switch (e.keyCode) {
        case 37: out.innerHTML = 'left'; e.preventDefault(); leftSelect(equation); break;
        case 38: out.innerHTML = 'up'; e.preventDefault(); upSelect(equation); break;
        case 39: out.innerHTML = 'right'; e.preventDefault(); rightSelect(equation); break;
        case 40: out.innerHTML = 'down'; e.preventDefault(); downSelect(equation); break;

// Specialkeys voor Wouter        
        case 173: replaceWithPlus(); keysList.push(173); break;
        case 164: replaceWithTimes(); keysList.push(164); break;
        case 192: replaceWithPower(); keysList.push(192); break;
        case 169: replaceWithMinus(); keysList.push(169); break;
        case 160: replaceWithDivide(); keysList.push(160); break;
        case 165: replaceWithNthroot(); keysList.push(165); break;
        case 61:  replaceWithEquality(); keysList.push(61); break;

// Specialkeys voor SVEN (hacky)
        case 189: replaceWithPlus(); break;
        case 186: replaceWithTimes(); break;
        case 220: replaceWithMinus(); break;
        case 219: replaceWithMinus(); break;
        case 221: replaceWithDivide(); break;
        case 192: replaceWithNthroot(); break;
        case 187: replaceWithEquality(); break;

// Cijfers (voor Wouter)
        case 49: e.preventDefault(); substituteSelected(selectIt('1'), equation); updateLatex(equation); break; 
        case 50: e.preventDefault(); substituteSelected(selectIt('2'), equation); updateLatex(equation); break;
        case 51: e.preventDefault(); substituteSelected(selectIt('3'), equation); updateLatex(equation); break;
        case 52: e.preventDefault(); substituteSelected(selectIt('4'), equation); updateLatex(equation); break;
        case 53: e.preventDefault(); substituteSelected(selectIt('5'), equation); updateLatex(equation); break;
        case 54: e.preventDefault(); substituteSelected(selectIt('6'), equation); updateLatex(equation); break;
        case 55: e.preventDefault(); substituteSelected(selectIt('7'), equation); updateLatex(equation); break;
        case 56: e.preventDefault(); substituteSelected(selectIt('8'), equation); updateLatex(equation); break;
        case 57: e.preventDefault(); substituteSelected(selectIt('9'), equation); updateLatex(equation); break;
        case 48: e.preventDefault(); substituteSelected(selectIt('0'), equation); updateLatex(equation); break;

// letters
        case 65: e.preventDefault(); substituteSelected(selectIt('a'), equation); updateLatex(equation); break; //  a
        case 66: e.preventDefault(); substituteSelected(selectIt('b'), equation); updateLatex(equation); break; //  b
        case 67: e.preventDefault(); substituteSelected(selectIt('c'), equation); updateLatex(equation); break; //  c
    }
};

// bij mij vs bij sven
// 61  -> 187
// 192 -> 220
// 165 -> 192
// 164 -> 186
// 160 -> 221
// 173 -> 189
// 169 -> 219

</script>

</p>

<ol>
    <li>een
        <script> document.write("nebun") </script>
    </li>
    <li>twee</li>
    <li>drie</li>
</ul>


</body>